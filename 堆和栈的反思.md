#	内存为什么要分堆和栈？
## 1.计算机内存那点事 ----- 内存的基本概念
- 在弄明白这个问题之前，我们首先要知道内存的概念。在学计算机基础课的时候，内存是这样定义的：
  <b>内存是用来储存计算机正在执行的程序和数据</b>。
- 国平的理解是：<b >内存是一种存储器，硬件上来说就是可以快速储存二进制数据的东东，和硬盘，磁盘等相比，内存存取速度快，容量小，资源稀缺，所有在开发的时候要合理利用内存。在某种程度上说，评价一个的算法或者程序的好坏，就是看占用内存资源多少。</b>
- 在早期的计算机上，内存的存取管理工作都是有程序员自己来完成的。在程序执行之前，首先需要将机器语言编写的程序输出到内存的某个固定区域上，并预先给变量 和数据分配好对应的内存地址（绝对地址或者相对地址），在java中如果有一个40个字段的javabean，几分钟就搞定。如果放到以前 恐怕要写 一早上，而且容易出错。想想那时多么令人dan 疼的一件事情，还好我躲过了那个时代。再也不用关心内存的存取管理。因为高级语言都已经帮我们把这些操作在底层实现了，<b>程序中使用的的存储单元都由逻辑变量(标识符)来表示，他们对应的内存地址都是由编译程序在编译或执行时分配的。</b>
- 所谓的逻辑变量就是我们在高级语言中定义的变量，例如<br>
		String name;<br>
		var  salary;<br>
		list<map> scores;<br><b>这些变量在编译或者执行的时候才会分配内存，所有叫逻辑上的变量。</b>
##  2.那么系统是如何分配内存,又如何回收那些用户不用的二是放的内存呢?　－－－动态存储管理
###  第一种情况 
- 在系统开始运行时将归它使用的内存区按需分割成若干大小相同的块，然后用指针连接成一个可利用的空间表，由于表中节点的大小相同，则分配是无需查找，只要将第一个节点分配给用户即可。同意，当用户释放内存时，系统只要将用户释放的空闲块插在表头即可。
###  第二中情况
- 用户请求分配的存储量有若干种大小的规格，高级语言中的基本类型，int ，float等
###  第三种情况
-  规格大小不固定（引用类型），也就是 new 出来的对象。
# <b>因此在程序运行时，内存中存储的数据可以大致分为2种，一种是固定大小的，另一种是不固定的。固定大小的数据在内存中存取速度快，相反不固定的存取相对麻烦。所以，把内存大致分为以下几种</b>
## 3.栈的概念
- 栈是由操作系统在创建线程的时候，系统自动创建，栈是由顶像下分配的， DELPHI 中默认的栈大小是 1M ，这个可以通过 Project->Options->Linker->Max Stack size 来改变其大小。
栈是线程执行代码的地方，操作系统根据系统调度算法来加载执行的代码，另外栈还存放函数的参数值，局部变量。栈的存取是按 4 字节偏移，不会根据需要动态增长，因此超出范围会报栈溢出。
### 栈中都放了那些东东
#### 1.基本数据类型（ Integer 、 Cardinal 、 Shortint 、 Smallint 、 Longint 、 Int64 、 Byte 、 Word 、 LongWord 、 Char ）都是在栈中的
#### 2. 指针类型是指针在栈中，指针所指向的地址在堆中
#### 3. 结构体在栈中
## 堆的概念
- 我们把在栈之外的分配内存都叫在堆上分配内存，堆是由程序员分配释放。在 DELPHI 中是用 GetMem.inc 中的代码来管理堆的，堆中包含许多大小不确定的块。初始状态下，堆仅有一个块，即堆本身。经过一段时间地取用和回收以后，堆中将可能只剩下一些“切割”后残余的“碎片”，且这些碎片可能已经无法再合并。此时，如果一个新的请求大于任何一个碎片，那么就必须再申请一个新的、大的块放在堆中。堆的使用永远是一个“拆东墙补西墙”的过程。
堆的大小是 2G ，在扩展内存模式下能达到 3G 。注意它与数据结构中的堆是两回事，它的分配方式类似于链表，访问“堆”的内容的时候需要先找到这个“堆”，然后再遍历链表，因此“堆”访问会比“栈”慢。
### 堆里有那些东东？
####   指针指向的内容是在堆中
####   动态数组的内容是在堆中
####   String 、 ShortString 、 WideString 的内容是在堆中
####   全局变量在堆中
## 堆和栈的比较
### 栈和堆的管理方式比较
栈：由操作系统自动分配，而且在栈上分配内存是由编译器自动完成的，栈不需要编译器管理，操作系统自动实现申请释放；
堆：由操作系统提供接口，各个编译器实现管理方式，由外部程序申请释放，如果外部程序在程序结束时没有释放，由操作系统强行释放，在 DELPHI 中是用 GetMem.inc 来实现内存管理；
### 栈和堆 的初始化比较
栈：分配的内存不会初始化，是一个垃圾值；
堆：分配的内存不会初始化，是一个垃圾值，但是 DELPHI 默认初始化类变量和全局变量；
###  栈和堆的申请方式 比较
栈：由系统自动分配，如在函数申明一个局部变量 i: Integer ；编译器会自动在栈中分配内存；
堆：由程序自己管理，需要程序员自己申请，并指明大小；
###  堆和栈的效率比较
栈：在栈上分配空间是直接用 add 指令，对 esp 进行移位，例如 add esp,-$44 ，可以在一个指令周期内完成；
堆： 操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的 FreeMem 语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 在堆中 分配内存的时候会用 HeapLock 和 HeapUnlock 加锁，因此在多线程中分配内存是线性的，效率低下；
### 栈和堆的大小限制 比较
栈：在 Windows 下栈默认大小是 1M, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow 。因此，能从栈获得的空间较小。
堆：在 Windows 下默认堆大小是 2GB ，堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
### 栈和堆 的超出范围比较
栈：超出栈大小会报栈溢出；
堆：超出堆大小会报 Out Of Memory ；
